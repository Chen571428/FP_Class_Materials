<!DOCTYPE HTML>
<html lang="zh-cn" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>初见函数式思维 - Programming Haskell</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programming Haskell</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-02-章初见函数式思维"><a class="header" href="#第-02-章初见函数式思维">第 02 章：初见函数式思维</a></h1>
<h3 id="01-两句很有哲理的话"><a class="header" href="#01-两句很有哲理的话">01 两句很有哲理的话</a></h3>
<ul>
<li>
<p>工欲善其事，必先利其器。</p>
</li>
<li>
<p>To a man with a hammer, everything looks like a nail.</p>
</li>
</ul>
<blockquote>
<ul>
<li>思维方式是一种工具；不能被思维方式束缚</li>
</ul>
</blockquote>
<h3 id="02-函数式思维-是一种什么样的思维方式"><a class="header" href="#02-函数式思维-是一种什么样的思维方式">02 “函数式思维” 是一种什么样的思维方式</a></h3>
<ul>
<li>
<p>使用 “数学中的函数” 作为 求解信息处理问题的基本成分。</p>
</li>
<li>
<p>“使用方式” 包括：</p>
<ul>
<li>
<p>从零开始，定义一些基本函数</p>
</li>
<li>
<p>把已有的函数组装起来，形成新的函数</p>
</li>
</ul>
</li>
</ul>
<h3 id="03-简要回顾数学中的函数"><a class="header" href="#03-简要回顾数学中的函数">03 简要回顾：数学中的函数</a></h3>
<blockquote>
<p><strong>定义：</strong> 函数 / Function</p>
<p>对任何两个集合<code>X</code>和<code>Y</code>，称两者之间的关系<code>f ⊆ X ✗ Y</code>是一个函数，当且仅当如下条件成立：</p>
<ul>
<li><code>∀ x ∈ X, ∃ (u, v) ∈ f, x = u</code></li>
<li><code>∀ (x, y) ∈ f, ∀ (u, v) ∈ f, x = u =&gt; y == v</code></li>
</ul>
<blockquote>
<p>也即：对<code>X</code>中的任何元素<code>x</code>，存在且仅存唯一一个元素<code>y ∈ Y</code>，满足<code>(x, y) ∈ f</code></p>
</blockquote>
</blockquote>
<h4 id="函数相关的表示符号"><a class="header" href="#函数相关的表示符号">函数相关的表示符号：</a></h4>
<p>对任何两个集合<code>X</code>和<code>Y</code>，</p>
<ul>
<li>
<p><code>X ✗ Y</code></p>
<ul>
<li>
<p>一个集合，其定义为：<code>{ (x, y) | x ∈ X, y ∈ Y }</code></p>
</li>
<li>
<p>也称为集合 <code>X</code> 和 <code>Y</code> 的 <strong>笛卡尔积</strong></p>
</li>
</ul>
</li>
<li>
<p><code>X -&gt; Y</code></p>
<ul>
<li>一个集合，包含且仅包含所有从<code>X</code>到<code>Y</code>的函数</li>
</ul>
</li>
<li>
<p><code>f : X -&gt; Y</code></p>
<ul>
<li>
<p>声明<code>f</code>是一个从<code>X</code>到<code>Y</code>的函数。也称：<code>f</code>是一个类型为<code>X -&gt; Y</code>的函数</p>
</li>
<li>
<p>称：<code>X</code>为<code>f</code>的<strong>定义域</strong> (Domain)；<code>Y</code>为<code>f</code>的<strong>值域</strong> (Codomain)</p>
</li>
</ul>
</li>
<li>
<p><code>f(x)</code></p>
<ul>
<li>
<p>函数<code>f</code>的定义域中元素<code>x</code>映射到的值域中的那个元素，</p>
</li>
<li>
<p>显然可知：</p>
<ul>
<li>
<p><code>f(x) : Y</code>，也即：<code>f(x)</code>的类型为<code>Y</code></p>
</li>
<li>
<p><code>(x, f(x)) ∈ f</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="常用的集合及其表示符号"><a class="header" href="#常用的集合及其表示符号">常用的集合及其表示符号：</a></h4>
<blockquote>
<p>在 Haskell 中，“类型” 和 “集合” 是同义词</p>
</blockquote>
<ul>
<li>
<p><code>ℕ</code>：自然数集合/类型</p>
</li>
<li>
<p><code>ℤ</code>：整数集合/类型</p>
</li>
<li>
<p><code>ℚ</code>：有理数集合/类型</p>
</li>
<li>
<p><code>ℝ</code>：实数集合/类型</p>
</li>
<li>
<p><code>𝔹 = { true, flse }</code>：布尔集合/类型。其中，</p>
<ul>
<li>
<p><code>true</code> 表示 “真”；<code>flse</code> 表示 “假”</p>
</li>
<li>
<p>稍后给出 <code>𝔹</code> 的一种更为形式化的定义</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>定义：</strong> 函数的组合 / Function Composition</p>
<p>对任何两个函数 <code>f : X -&gt; Y</code>、<code>g : Y -&gt; Z</code>，两者的组合，记为 <code>g * f</code>，是一个函数。</p>
<p>该函数的定义如下：</p>
<pre><code class="language-haskell">[ X Y Z : Set, f : X -&gt; Y, g : Y -&gt; Z ]
def g * f : X -&gt; Z = [x : X] g(f(x))
</code></pre>
<p>说明：</p>
<ul>
<li>
<p>上述定义不是采用 Haskell 语言书写的程序</p>
</li>
<li>
<p>本章中出现的所有程序 (除了最后一个)，都不是 Haskell 程序</p>
<ul>
<li>这些程序所采用的语法，来源于我们正在设计中的一种用于数学证明的语言</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="04-为什么在函数的基础上可以形成一种思维方式"><a class="header" href="#04-为什么在函数的基础上可以形成一种思维方式">04 为什么在函数的基础上，可以形成一种思维方式</a></h3>
<ul>
<li>
<p>函数可以建模 <strong>“变换”</strong> 和 <strong>“因果关系”</strong></p>
<ul>
<li>
<p>信息处理问题，本质上是一种信息的变换问题</p>
</li>
<li>
<p>在面向特定领域问题的软件应用中，大量涉及对物理世界中因果关系的仿真</p>
</li>
</ul>
</li>
</ul>
<h3 id="05-几个简单的函数"><a class="header" href="#05-几个简单的函数">05 几个简单的函数</a></h3>
<ul>
<li>
<p><strong>逻辑非</strong>函数</p>
<pre><code class="language-haskell">def not : 𝔹 -&gt; 𝔹 = [b] match b {
    true =&gt; flse,
    flse =&gt; true,
}
</code></pre>
</li>
<li>
<p><strong>逻辑与</strong>函数</p>
<pre><code class="language-haskell">def and : (𝔹 ✗ 𝔹) -&gt; 𝔹 = [p] match p {
    (true, true) =&gt; true,
    _            =&gt; flse,
}
</code></pre>
<p>另一种定义方式:</p>
<pre><code class="language-haskell">def and : 𝔹 -&gt; 𝔹 -&gt; 𝔹 = [l] [r] match (l, r) {
    (true, true) =&gt; true,
    _            =&gt; flse,
}
</code></pre>
</li>
<li>
<p>为了定义关于自然数<code>ℕ</code>的函数，我们首先需要给出<code>ℕ</code>的定义</p>
<pre><code class="language-haskell">def ℕ : Type = {
    ctor zero : Self
    ctor succ : Self -&gt; Self
}
</code></pre>
<p>这是一种递归定义，其含义如下：</p>
<ul>
<li>
<p><code>zero</code> 是 <code>ℕ</code> 中的一个元素</p>
</li>
<li>
<p>如果 <code>n</code> 是 <code>ℕ</code> 中的一个元素，那么，<code>succ n</code> 也是<code>ℕ</code> 中的一个元素</p>
</li>
<li>
<p><code>ctor</code> 是一个关键字 (Key Word)，其英文单词 “constructor” 的缩写</p>
<ul>
<li>
<p><code>ctor</code> 后面的那个元素是一个公理 (无需给出元素的定义)</p>
<ul>
<li>所谓公理，就是一个神秘存在</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么可以这样定义自然数呢？</p>
<p>因为在这种定义下，我们可以做出如下设定：</p>
<ul>
<li><code>0 === zero</code></li>
<li><code>1 === succ(zero)</code></li>
<li><code>2 === succ(succ(zero))</code></li>
<li><code>3 === succ(succ(succ(zero)))</code>
<br> <br></li>
</ul>
</blockquote>
<blockquote>
<p><strong>小和尚：</strong></p>
<ul>
<li>这不就是上古传说中的 <strong>“结绳记数”</strong> 吗！</li>
</ul>
<p><strong>唐僧：</strong></p>
<ul>
<li>思维真敏捷；真是一个值得教育的好孩子！</li>
</ul>
<p><strong>小和尚：</strong></p>
<ul>
<li>但是，这么 low 的自然数定义，真的适合在北京大学的课堂上讲吗？</li>
</ul>
<p><strong>唐僧：</strong></p>
<ul>
<li>
<p>我猜测，也许你的思维被你的高中数学老师囚禁在数学宇宙的一片荒漠中了</p>
</li>
<li>
<p>采用类似的方式，我们也可以对<code>𝔹</code>给出形式化的定义</p>
<pre><code class="language-haskell">def 𝔹 : Type = {
    ctor flse : Self,
    ctor true : Self,
}
</code></pre>
</li>
</ul>
</blockquote>
</li>
<li>
<p>自然数的<strong>加法运算</strong></p>
<pre><code class="language-haskell">def plus : ℕ -&gt; (ℕ -&gt; ℕ) = [a] [b] match (a, b) {
    (m, zero)    =&gt; m,
    (m, succ(n)) =&gt; succ(plus(m)(n))
}
</code></pre>
<p>加法运算示例：</p>
<pre><code class="language-haskell">    plus(3)(4)  -- 因为实在受不了“结绳记数”的自然数，所以局部回归人类世俗文明😅
=== plus(3)(succ(3))
=== succ(plus(3)(3))
=== succ(plus(3)(succ(2)))
=== succ(succ(plus(3)(2)))
=== succ(succ(plus(3)(succ 1)))
=== succ(succ(succ(plus(3)(1))))
=== succ(succ(succ(plus(3)(succ 0))))
=== succ(succ(succ(succ(plus(3)(0)))))
=== succ(succ(succ(succ(3))))
=== (succ * succ * succ * succ)(3)
</code></pre>
<blockquote>
<p>不要被上面这种看似复杂的定义所困扰。</p>
<p>它只不过用递归的方式定义了一件很简单的事情：</p>
<pre><code class="language-haskell">  plus(m)(n) === (succ * succ * succ * ... * succ)(m)
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    "the composition of n succ"
</code></pre>
</blockquote>
</li>
<li>
<p>自然数的<strong>乘法运算</strong></p>
<pre><code class="language-haskell">def mult : ℕ -&gt; (ℕ -&gt; ℕ) = [a] [b] match (a, b) {
    (m, zero)    =&gt; zero,
    (m, succ(n)) =&gt; plus(m)(mult(m)(n))
}
</code></pre>
<p>乘法运算示例：</p>
<pre><code class="language-haskell">    mult(3)(4)
=== mult(3)(succ 3)
=== plus(3)(mult(3)(3))
=== plus(3)(mult(3)(succ 2))
=== plus(3)(plus(3)(mult(3)(2)))
=== plus(3)(plus(3)(mult(3)(succ 1)))
=== plus(3)(plus(3)(plus(3)(mult(3)(1))))
=== plus(3)(plus(3)(plus(3)(mult(3)(succ 0))))
=== plus(3)(plus(3)(plus(3)(plus(3)(mult(3)(0)))))
=== plus(3)(plus(3)(plus(3)(plus(3)(0))))
=== (plus(3) * plus(3) * plus(3) * plus(3))(0)
</code></pre>
<blockquote>
<p>不要被上面这种看似复杂的定义所困扰。</p>
<p>它只不过用递归的方式定义了一件很简单的事情：</p>
<pre><code class="language-haskell">  mult(m)(n) === (plus(m) * plus(m) * ... * plus(m))(zero)
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   "the composition of n plus(m)"
</code></pre>
</blockquote>
</li>
<li>
<p>自然数的<strong>指数运算</strong></p>
<pre><code class="language-haskell">def expn : ℕ -&gt; (ℕ -&gt; ℕ) = [a] [b] match (a, b) {
    (m, zero)    =&gt; succ(zero),
    (m, succ(n)) =&gt; mult(m)(expn(m)(n))
}
</code></pre>
<p>指数运算示例：</p>
<pre><code class="language-haskell">    expn(3)(4)
=== expn(3)(succ 3)
=== mult(3)(expn(3)(3))
=== mult(3)(expn(3)(succ 2))
=== mult(3)(mult(3)(expn(3)(2)))
=== mult(3)(mult(3)(expn(3)(succ 1)))
=== mult(3)(mult(3)(mult(3)(expn(3)(1))))
=== mult(3)(mult(3)(mult(3)(expn(3)(succ 0))))
=== mult(3)(mult(3)(mult(3)(mult(3)(expn(3)(0)))))
=== mult(3)(mult(3)(mult(3)(mult(3)(1))))
=== (mult(3) * mult(3) * mult(3) * mult(3))(1)
</code></pre>
<blockquote>
<p>不要被上面这种看似复杂的定义所困扰。</p>
<p>它只不过用递归的方式定义了一件很简单的事情：</p>
<pre><code class="language-haskell">  expn(m)(n) === (mult(m) * mult(m) * ... * mult(m))(succ(zero))
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   "the composition of n mult(m)"
</code></pre>
</blockquote>
<blockquote>
<p><strong>小和尚：</strong></p>
<ul>
<li>总是n个相同函数的组合；能不能有些新东西呢？</li>
</ul>
<p><strong>唐僧：</strong></p>
<ul>
<li>何必让自己这么累；这样划水不挺好嘛！
<br> <br></li>
</ul>
</blockquote>
</li>
<li>
<p><strong>阶乘运算</strong></p>
<pre><code class="language-haskell">def fact : ℕ -&gt; ℕ = [m] match m {
    zero    =&gt; succ(zero),
    succ(n) =&gt; mult(succ(n))(fact(n)),
}
</code></pre>
<blockquote>
<p>不要被上面这种看似复杂的定义所困扰</p>
<p>它只不过用递归的方式定义了一件很简单的事情：</p>
<pre><code class="language-haskell">fact(m) === (mult(m) * mult(m - 1) * ... * mult(1))(1)
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 "the composition of n mult(_)"
</code></pre>
</blockquote>
<blockquote>
<p><strong>唐僧：</strong> 看，是不是有那么一点点新东西了 😅</p>
</blockquote>
</li>
<li>
<p><strong>斐波那契函数</strong></p>
<pre><code class="language-haskell">def fib : ℕ -&gt; ℕ = [m] match m {
    zero          =&gt; zero,
    succ(zero)    =&gt; succ(zero),
    succ(succ(n)) =&gt; plus(fib(n))(fib(succ n)),
}
</code></pre>
<p>斐波那契函数运算示例：</p>
<pre><code class="language-haskell">    fib(5)
=== plus(fib(3))(fib(4))
=== plus(plus(fib(1))(fib(2)))(plus(fib(2))(fib(3)))
=== plus(plus(1)(plus(fib(0))(fib(1))))(plus(plus(fib(0))(fib(1)))(plus(fib(1))(fib(2))))
=== plus(plus(1)(plus(0)(1)))(plus(plus(0)(1))(plus(1)(plus(fib(0))(fib(1)))))
=== plus(plus(1)(plus(0)(1)))(plus(plus(0)(1))(plus(1)(plus(0)(1))))
</code></pre>
<blockquote>
<p><strong>小和尚：</strong> 这下好了，没有规律了。看你怎么圆过来 😜</p>
</blockquote>
</li>
</ul>
<h3 id="06-自然数上的-fold-函数"><a class="header" href="#06-自然数上的-fold-函数">06 自然数上的 fold 函数</a></h3>
<ul>
<li>
<p><code>plus</code> <code>mult</code> <code>expn</code> 这三个函数之间存在共性</p>
</li>
<li>
<p>这种共性可以被封装在一个函数中</p>
<pre><code class="language-haskell">[T : Type]
def fold
: (T -&gt; T) -&gt; (T -&gt; (ℕ -&gt; T))
= [h : T -&gt; T] [c : T] [m : ℕ] match m {
    zero   =&gt; c,
    succ n =&gt; h(fold(h)(c)(n))
  }
  ------ 引入一点语法糖 ------
= [h : T -&gt; T, c : T, m : ℕ] match m {
    zero   =&gt; c,
    succ n =&gt; h(fold(h)(c)(n))
  }
</code></pre>
</li>
<li>
<p>给定 <code>h : T -&gt; T</code>, <code>c : T</code>，令 <code>f === fold(h)(c)</code>，则可知：</p>
<ul>
<li>
<p><code>f(zero) === c</code></p>
</li>
<li>
<p><code>f(succ n) === h(f(n))</code></p>
</li>
</ul>
</li>
<li>
<p>如果不理解这个定义的含义，请看如下解释：</p>
<blockquote>
<p>给定一个自然数 <code>n</code>，可知：</p>
<pre><code class="language-haskell">   n === (succ * succ * succ * ... * succ)(zero)
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            "the composition of n succ"
</code></pre>
</blockquote>
<blockquote>
<p>已知 <code>f === fold(h)(c)</code>，则可知：</p>
<pre><code class="language-haskell">f(n) === ( h   *   h   *  h  *  ... *  h )(zero)
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            "the composition of n h"
</code></pre>
</blockquote>
<blockquote>
<p>也即：</p>
<ul>
<li>
<p><code>f(n)</code> 把 <code>n</code> 中的 <code>zero</code> 替换为 <code>c</code>，把每一个 <code>succ</code> 替换为 <code>h</code></p>
</li>
<li>
<p><code>n</code> 和 <code>f(n)</code> 是同构的，即：两者具有相同的结构</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>使用 <code>fold</code> 函数，可以对 <code>plus</code> <code>mult</code> <code>expn</code> 这三个函数进行更深刻的定义</p>
<pre><code class="language-haskell">def plus : ℕ -&gt; (ℕ -&gt; ℕ) = [m] fold(succ)(m)

def mult : ℕ -&gt; (ℕ -&gt; ℕ) = [m] fold(plus(m))(zero)

def expn : ℕ -&gt; (ℕ -&gt; ℕ) = [m] fold(mult(m))(succ(zero))
</code></pre>
<p>示例：</p>
<pre><code class="language-haskell">               ----the composition of n succ -----
  n        === (succ    * succ    * ... * succ   )(zero)
  |              |         |         |     |
plus(m)(n) === (succ    * succ    * ... * succ   )(m)
  |              |         |         |     |
mult(m)(n) === (plus(m) * plus(m) * ... * plus(m))(zero)
  |              |         |         |     |
expn(m)(n) === (mult(m) * mult(m) * ... * mult(m))(succ(zero))

</code></pre>
</li>
<li>
<p>使用<code>fold</code>函数，也可以对 <code>fact</code> <code>fib</code> 这两个函数进行更深刻的定义</p>
<p>首先引入两个辅助函数：</p>
<pre><code class="language-haskell">[A B : Type]
def fst : A ✗ B -&gt; A = [(a, b)] a

[A B : Type]
def snd : A ✗ B -&gt; B = [(a, b)] b
</code></pre>
<p><code>fact</code>函数的定义：</p>
<pre><code class="language-haskell">def fact : ℕ -&gt; ℕ = {
    def f
    : ℕ ✗ ℕ -&gt; ℕ ✗ ℕ
    = [(m, n)] (m + 1, (m + 1) * n);

    ret snd * (fold(f)(0, 1));
}
</code></pre>
<pre><code class="language-haskell">                 ----the composition of n succ ----
  n     ===      ( succ  *  succ  *  ...  *  succ )(0)
  |                 |        |        |       |     |
fact(n) === snd( (  f    *   f    *  ...  *   f   )(0, 1) )
</code></pre>
<p><code>fib</code>函数的定义：</p>
<pre><code class="language-haskell">def fib : ℕ -&gt; ℕ = {
    def g
    : ℕ ✗ ℕ -&gt; ℕ ✗ ℕ
    = [(m, n)] (n, m + n);

    ret fst * (fold(g)(0, 1));
}
</code></pre>
<pre><code class="language-haskell">                 ----the composition of n succ ----
  n     ===      ( succ  *  succ  *  ...  *  succ )(0)
  |                 |        |        |       |     |
fib(n)  === fst( (  g    *   g    *  ...  *   g   )(0, 1) )
</code></pre>
</li>
</ul>
<h3 id="07-list-类型"><a class="header" href="#07-list-类型">07 List 类型</a></h3>
<ul>
<li>
<p>在信息处理问题中，经常涉及一组按照某种顺序排列的数据；</p>
<p>我们将这类数据用 List 类型进行表示。</p>
<ul>
<li>
<p>例如：对于排序问题</p>
<ul>
<li>
<p>待排序的数据通常采用 List 的方式进行输入</p>
</li>
<li>
<p>排序的结果自然也以 List 的方式返回</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>List 类型的定义</p>
<pre><code class="language-haskell">def List : Type -&gt; Type = [A] {
    ctor nil  : Self,
    ctor (+&gt;) : A -&gt; Self -&gt; Self,
}
</code></pre>
</li>
<li>
<p>List 类型的示例</p>
<ul>
<li>
<p><code>List(ℕ)</code>：自然数序列类型</p>
</li>
<li>
<p><code>nil</code>：一个不包含任何元素的空序列</p>
</li>
<li>
<p><code>1 +&gt; nil</code>：仅包含 1 个元素 <code>1</code> 的自然数序列</p>
</li>
<li>
<p><code>1 +&gt; (2 +&gt; (3 +&gt; (4 +&gt; nil)))</code>：包含 4 个元素 <code>1</code> <code>2</code> <code>3</code> <code>4</code> 的自然数序列</p>
</li>
</ul>
</li>
<li>
<p>List 类型相关的函数</p>
<p>添加元素函数：</p>
<pre><code class="language-haskell">[T : Type]
def cons
: T -&gt; (List(T) -&gt; List(T))
= [x, xs] x +&gt; xs

-- 这个函数就是把运算符 +&gt; 进行了函数化
</code></pre>
<p>长度函数：</p>
<pre><code class="language-haskell">[T : Type]
def len
: List(T) -&gt; ℕ
= [xs] match xs {
    nil     =&gt; 0,
    a +&gt; yx =&gt; 1 + len(yx)
}
</code></pre>
<p>逆序函数：</p>
<pre><code class="language-haskell">[T : Type]
def rev
: List(T) -&gt; List(T)
= {
    def rev-memo
    : List(T) -&gt; (List(T) -&gt; List(T))
    = [xs, ys] match ys {
        nil     =&gt; xs,
        m +&gt; ms =&gt; rev-memo(m +&gt; xs)(ms),
    };

    ret rev-memo(nil);
}
</code></pre>
<p>序列拼接函数：</p>
<pre><code class="language-haskell">[T : Type]
def concat
: List(T) -&gt; (List(T) -&gt; List(T))
= [xs, ys] match xs {
    nil     =&gt; ys,
    m +&gt; ms =&gt; m +&gt; (concat(ms)(ys)),
}
</code></pre>
<p>过滤函数：</p>
<pre><code class="language-haskell">[T : Type]
def filter
: (T -&gt; 𝔹) -&gt; (List(T) -&gt; List(T))
= [f, xs] match xs {
    nil     =&gt; nil,
    m +&gt; ms =&gt; match f(m) {
        true =&gt; m +&gt; filter(f)(ms),
        flse =&gt;      filter(f)(ms),
    }
}
</code></pre>
</li>
</ul>
<h3 id="08-list-上的-fold-函数"><a class="header" href="#08-list-上的-fold-函数">08 List 上的 fold 函数</a></h3>
<ul>
<li>
<p>如果我的理解没有错误，在任何类型上都存在 fold 函数</p>
<div class="warning">
<pre><code>这个观点待确认。
数学上的事情，只要没有给出证明，都不能随意相信。
</code></pre>
</div>
</li>
<li>
<p>无论如何，<code>List</code> 类型上存在 fold 函数，而且存在两个。</p>
<p>我们将这两个函数分别命名为 <code>foldl</code> 和 <code>foldr</code>。</p>
<ul>
<li>其中的后缀 <code>l</code> 和 <code>r</code> 分别表示 <code>left</code> 和 <code>right</code></li>
</ul>
</li>
<li>
<p><code>foldr</code> 函数</p>
<pre><code class="language-haskell">[A B : Type]
def foldr
: (A -&gt; (B -&gt; B)) -&gt; (B -&gt; (List(A) -&gt; B))
= [h : A -&gt; (B -&gt; B), b : B, xs : List(A)] match xs {
    nil     =&gt; b,
    a +&gt; ys =&gt; h(a)(foldr(h)(b)(ys))
}
</code></pre>
<blockquote>
<p>如果不理解这个定义，请看如下解释：</p>
<ul>
<li>
<p>给定 <code>xs : List(A)</code>，不失一般性，令：</p>
<pre><code class="language-haskell">xs    === xn  +&gt;  xn-1  +&gt;  ...  +&gt;  x1  +&gt;  nil
</code></pre>
<p>则可知：</p>
<pre><code class="language-haskell">xs    === ( cons(xn) * cons(xn-1) * ... * cons(x1) )(nil)
</code></pre>
</li>
<li>
<p>已知 <code>f === foldr(h)(b)</code>，则可知：</p>
<pre><code class="language-haskell">f(xs) === (    h(xn) *    h(xn-1) * ... *    h(x1) )(b)
</code></pre>
</li>
<li>
<p>也即：</p>
<ul>
<li>
<p><code>f(xs)</code>把<code>xs</code>中的<code>nil</code>替换为<code>b</code>，把<code>xs</code>中的每一个<code>cons</code>替换为<code>h</code></p>
</li>
<li>
<p><code>xs</code> 和 <code>f(xs)</code> 是同构的，即：两者具有相同的结构</p>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>
<p><code>foldl</code> 函数</p>
<pre><code class="language-haskell">[A B : Type]
def foldl
: (B -&gt; (A -&gt; B)) -&gt; (B -&gt; (List(A) -&gt; B))
= [h : B -&gt; (A -&gt; B), b : B, xs : List(A)] match xs {
    nil     =&gt; b,
    a +&gt; ys =&gt; foldl(h)(h(b)(a))(ys),
}
</code></pre>
<blockquote>
<p>如果不理解这个定义，请看如下解释：</p>
<ul>
<li>
<p>引入一个工具函数</p>
<pre><code class="language-haskell">[A B C : Type]
def flip
: (A -&gt; (B -&gt; C)) -&gt; (B -&gt; (A -&gt; C))
= [f, b, a] f a b
</code></pre>
</li>
<li>
<p>给定 <code>xs : List(A)</code>，不失一般性，令：</p>
<pre><code class="language-haskell">xs    === xn  +&gt;  xn-1  +&gt;  ...  +&gt;  x1  +&gt;  nil
</code></pre>
<p>则可知：</p>
<pre><code class="language-haskell">xs    === ( cons(xn) * cons(xn-1) * ... * cons(x1) )(nil)
</code></pre>
</li>
<li>
<p>已知 <code>f === foldr(h)(b)</code>，令 <code>h' = flip(h)</code>，则可知：</p>
<pre><code class="language-haskell">f(xs) === (   h'(x1) *   h'(x2)   * ... *   h'(xn) )(b)
</code></pre>
</li>
<li>
<p>也即：</p>
<ul>
<li>
<p><code>f(xs)</code>把<code>xs</code>中的<code>nil</code>替换为<code>b</code>，把<code>xs</code>中的每一个<code>cons</code>替换为<code>h'</code></p>
</li>
<li>
<p>同时，还顺带逆序了一下</p>
</li>
</ul>
</li>
<li>
<p>但实际上，<strong>并不存在一个显式的逆序环节</strong>；更真实的计算过程如下</p>
<pre><code class="language-haskell">f(xs) === b ≺ xn ≺ xn-1 ≺ ... ≺ x1 ≺ nil
</code></pre>
<p>其中：运算符 <code>≺</code> 具有左结合性，且 <code>b ≺ a === h(b)(a)</code></p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="09-使用fold函数重定义list相关的函数"><a class="header" href="#09-使用fold函数重定义list相关的函数">09 使用fold函数，重定义List相关的函数</a></h3>
<ul>
<li>
<p><code>len</code> 函数</p>
<pre><code class="language-haskell">[A : Type]
def len
: List(A) -&gt; ℕ
= {
    def h
    : A -&gt; ℕ -&gt; ℕ
    = [_, n] n + 1;

    ret foldr(h)(0)
}
</code></pre>
<blockquote>
<pre><code class="language-haskell">    xs  === ( cons(xn) * cons(xn-1) * ... * cons(x1) )(nil)
len(xs) === (    h(xn) *    h(xn-1) * ... *    h(x1) )(0)
</code></pre>
</blockquote>
</li>
<li>
<p><code>rev</code> 函数</p>
<pre><code class="language-haskell">[A : Type]
def rev
: List(A) -&gt; List(A)
= foldl(flip(cons))(nil)
</code></pre>
</li>
<li>
<p><code>concat</code> 函数</p>
<pre><code class="language-haskell">[A : Type]
def concat
: List(A) -&gt; (List(A) -&gt; List(A))
= [xs, ys] foldr(cons)(ys)(xs)
</code></pre>
</li>
<li>
<p><code>filter</code> 函数</p>
<pre><code class="language-haskell">[A : Type]
def filter
: (A -&gt; 𝔹) -&gt; (List(A) -&gt; List(A))
= [f] {
    def h
    : (A -&gt; 𝔹) -&gt; (A -&gt; (List(A) -&gt; List(A)))
    = [f, a, xs] match f(a) {
        true =&gt; a +&gt; xs,
        flse =&gt; xs,
    }

    ret foldr(h(f))(nil);
}
</code></pre>
<blockquote>
<pre><code class="language-haskell">          xs  === ( cons(xn) * cons(xn-1) * ... * cons(x1) )(nil)
filter(f)(xs) === ( h(f)(xn) * h(f)(xn-1) * ... * h(f)(x1) )(nil)
</code></pre>
</blockquote>
</li>
</ul>
<h3 id="10-一种排序算法"><a class="header" href="#10-一种排序算法">10 一种排序算法</a></h3>
<ul>
<li>
<p>快速排序算法</p>
<pre><code class="language-haskell">def qsort
: List(ℕ) -&gt; List(ℕ)
= [xs] match {
    nil     =&gt; nil,
    n +&gt; ns =&gt; {
       def left = qsort(filter([m] m &lt;  n)(ns));
       def rigt = qsort(filter([m] m &gt;= n)(ns));

       ret concat(left)(n +&gt; rigt);
    }
}
</code></pre>
<blockquote>
<p><strong>小和尚：</strong></p>
<ul>
<li>这段代码看起来还不错 👍</li>
</ul>
<p><strong>唐僧：</strong></p>
<ul>
<li>
<p>你的审美能力看起来也不错 👏</p>
</li>
<li>
<p>可以让你看一下去年的形式：</p>
<pre><code class="language-haskell">qsort : List(ℕ) -&gt; List(ℕ)
qsort(nil) = nil
qsort(n +&gt; ns) = concat(concat(qsort(filter(lt(n))(ns)))([n]))(qsort(filter(ge(n))(ns)))
where
    lt : ℕ -&gt; (ℕ -&gt; 𝔹)
    lt(n)(m) = if m &lt; n then true else flse

    ge : ℕ -&gt; (ℕ -&gt; 𝔹)
    ge(n)(m) = not(lt(n)(m))
</code></pre>
</li>
</ul>
<p><strong>小和尚：</strong></p>
<ul>
<li>如果这就是用 FP 书写的算法，此生绝不学 FP！</li>
</ul>
<p><strong>唐僧：</strong></p>
<ul>
<li>好孩子，如果给你三生三世的财富，学否？</li>
</ul>
<p><strong>小和尚：</strong></p>
<ul>
<li>佛学工作者可是不能撒谎的哦！！！
<br> <br></li>
</ul>
</blockquote>
</li>
<li>
<p><strong>内容</strong> 与 <strong>形式</strong></p>
<ul>
<li>
<p>这是一个关于 “内容” 与 “形式” 两者之间关系的问题</p>
<ul>
<li>
<p>内容：对自然数序列进行排序的一种方法</p>
</li>
<li>
<p>形式：表现这种排序方法的形式</p>
</li>
</ul>
</li>
<li>
<p>进一步而言，去年的程序存在的问题可以表述为：</p>
<ul>
<li>“形式” 小于 “内容”: 内容是很好的，但形式实在是太糟糕了</li>
</ul>
</li>
<li>
<p>如果你能体会到这一点，你会发现：这个问题的严重程度并不像表面上看起来的那样</p>
</li>
<li>
<p>为什么这么说呢？因为，本质（内容）毕竟还是很好的</p>
</li>
</ul>
</li>
<li>
<p><strong>重走长征路</strong></p>
<ul>
<li>
<p>在某种意义上，我们正在“重走长征路”</p>
</li>
<li>
<p>在很多年以前，科研工作者们就已经意识到了这个问题</p>
<ul>
<li>即：函数式思维的 “形式” 小于 “内容”</li>
</ul>
</li>
<li>
<p>在这个问题的驱使下，他/她们设计了各种各样的函数式程序设计语言</p>
</li>
<li>
<p>我们即将介绍的Haskell语言，就是这些函数式程序设计语言的集大成者</p>
</li>
<li>
<p>不过，目前看来，Haskell 语言正在老去：<strong>一鲸落，万物生！</strong></p>
<ul>
<li>例如，本章中程序的语法，就是在 Haskell 语言的基础上改良形成的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="11-剧透采用-haskell-语言编写的-qsort-算法"><a class="header" href="#11-剧透采用-haskell-语言编写的-qsort-算法">11 剧透：采用 Haskell 语言编写的 qsort 算法</a></h3>
<pre><code class="language-haskell">qsort :: Ord a =&gt; [a] -&gt; [a]
qsort []     	= []
qsort (p:xs)	= qsort lt ++ [p] ++ qsort ge
  where
    lt = filter (&lt;  p) xs
    ge = filter (&gt;= p) xs
</code></pre>
<h3 id="本章作业"><a class="header" href="#本章作业">本章作业</a></h3>
<blockquote>
<div class="warning">
<p>本章没有作业。</p>
<p>但是，你需要想清楚：这门课是否适合你。</p>
</div>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="01_intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="01_intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
